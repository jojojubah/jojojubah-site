<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>₿itcoin Runner</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background: #000;
            max-width: 100vw;
            max-height: 80vh;
            border: 1px solid #333;
            touch-action: manipulation;
        }

        #topScore {
            font-size: 16px;
            color: #fff;
            margin: 5px 0;
        }
        
        h1 {
            font-size: 1.5em;
            margin: 10px 0;
            color: white;
        }
        
        p {
            font-size: 0.9em;
            margin: 5px 0;
            color: white;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.2em;
                margin: 5px 0;
            }
            
            p {
                font-size: 0.8em;
                margin: 2px 0;
            }
            
            canvas {
                max-height: 70vh;
            }
        }
    </style>
</head>
<body>
    <h1 style="color: white;">₿itcoin Runner</h1>
    <canvas id="gameCanvas"></canvas>
    <p style="color: white;">Tap or press SPACE to start. Double jump enabled! Avoid the dips and collect coins!</p>
    <p id="topScore">Top Score: 0</p>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing function
        function resizeCanvas() {
            const isMobile = window.innerWidth <= 768;
            const maxWidth = isMobile ? window.innerWidth * 0.95 : Math.min(800, window.innerWidth * 0.9);
            const maxHeight = isMobile ? window.innerHeight * 0.7 : Math.min(600, window.innerHeight * 0.8);
            
            // Maintain 4:3 aspect ratio
            const aspectRatio = 4 / 3;
            let canvasWidth, canvasHeight;
            
            if (maxWidth / maxHeight > aspectRatio) {
                // Height is the limiting factor
                canvasHeight = maxHeight;
                canvasWidth = maxHeight * aspectRatio;
            } else {
                // Width is the limiting factor
                canvasWidth = maxWidth;
                canvasHeight = maxWidth / aspectRatio;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Update game variables that depend on canvas size
            groundHeight = canvasHeight - 50;
            if (typeof player !== 'undefined') {
                player.y = groundHeight - player.height;
            }
            
            if (typeof stars !== 'undefined') {
                // Regenerate stars for new canvas size
                stars.length = 0;
                for (let i = 0; i < 100; i++) {
                    stars.push({
                        x: Math.random() * canvasWidth,
                        y: Math.random() * canvasHeight,
                        size: Math.random() * 2,
                        twinkle: Math.random() * 0.5 + 0.5,
                    });
                }
            }
            
            return { width: canvasWidth, height: canvasHeight };
        }
        
        // Initial canvas setup
        const { width: canvasWidth, height: canvasHeight } = resizeCanvas();
        
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const newSize = resizeCanvas();
                // Update game variables that depend on canvas size
                speed = Math.max(3, newSize.width / 300);
            }, 250);
        });

        // Game Variables (dynamic based on canvas size)
        let groundHeight = canvas.height - 50;
        const player = {
            x: 50,
            y: groundHeight - 20,
            width: 20,
            height: 20,
            dy: 0,
            jump: -12,
            gravity: 0.5,
            jumpsLeft: 2,
            colorProgress: 0,
            colorDirection: 1, // 1 for increasing, -1 for decreasing
        };

        let obstacles = [];
        let coins = [];
        let fragments = [];
        let glitchCoin = null;
        let score = 0;
        let level = 1;
        let topScore = parseInt(localStorage.getItem('topScore')) || 0;
        let isGameOver = false;
        let speed = Math.max(3, canvasWidth / 300);
        let gameStarted = false;
        let frameCount = 0;

        let glitchActive = false;
        let glitchTimer = 0;

        let groundOffset = 0;

        const coinSymbols = ['£', '₿', '€'];

        // Stars for Background (will be populated after canvas is sized)
        let stars = [];

        // Ground Objects
        let groundObjects = [];

        // Element Colors and Glow Effects
        let obstacleColor;
        let coinColor;
        let starColor;
        let obstacleGlow;
        let coinGlow;
        let starGlow;
        let playerGlow;

        // Colors for player transition
        const colorStart = '#0000FF'; // Blue
        const colorEnd = '#808080';   // Grey

        // Sound effect for coin collection
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playCoinSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Reduced volume
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // New function for glitch coin sound effect
        function playGlitchCoinSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const now = audioContext.currentTime;

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, now);
            oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.2);
            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start(now);
            oscillator.stop(now + 0.2);
        }

        // Function to get a random HSL color
        function getRandomColor() {
            const h = Math.floor(Math.random() * 360);
            const s = 100;
            const l = 50;
            return `hsl(${h}, ${s}%, ${l}%)`;
        }

        // Draw Background
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
            gradient.addColorStop(0, '#0f0f5e'); // Light blue
            gradient.addColorStop(1, '#01012c'); // Dark blue
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            stars.forEach((star) => {
                ctx.save(); // Save the current state
                ctx.globalAlpha = Math.abs(Math.sin(frameCount / 50) * star.twinkle);
                ctx.fillStyle = starColor;
                ctx.shadowBlur = starGlow;
                ctx.shadowColor = starColor;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore(); // Restore the previous state
            });
        }

        // Generate Ground Objects
        function generateGroundObjects() {
            // Randomly decide whether to add a new object
            if (Math.random() < 0.1) { // Adjust frequency here
                let newObject = {
                    x: canvas.width + Math.random() * canvas.width,
                    y: groundHeight,
                    type: '',
                    size: Math.random() * 20 + 10,
                };

                const objectType = Math.random();
                if (objectType < 0.5) {
                    newObject.type = 'crater';
                } else {
                    newObject.type = 'rock';
                }

                groundObjects.push(newObject);
            }
        }

        // Draw Ground with Random Objects
        function drawGround() {
            groundOffset -= speed;
            if (groundOffset <= -canvasWidth) groundOffset = 0;

            ctx.fillStyle = '#444'; // Moon gray
            for (let i = 0; i <= 1; i++) {
                ctx.fillRect(groundOffset + i * canvasWidth, groundHeight, canvasWidth, canvasHeight - groundHeight);
            }

            // Draw ground objects
            groundObjects = groundObjects.filter((obj) => {
                obj.x -= speed;
                if (obj.x + obj.size < 0) return false;

                if (obj.type === 'crater') {
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y + 10, obj.size, 0, Math.PI, true);
                    ctx.fill();
                } else if (obj.type === 'rock') {
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.ellipse(obj.x, obj.y + 10, obj.size / 2, obj.size / 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                return true;
            });
        }

        // Draw Player with Color Transition
        function drawPlayer() {
            // Update player color
            const t = player.colorProgress;

            const interpolatedColor = interpolateColor(colorStart, colorEnd, t);
            ctx.fillStyle = interpolatedColor;

            ctx.shadowBlur = playerGlow;
            ctx.shadowColor = interpolatedColor;

            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.width / 2, 0, Math.PI * 2);
            ctx.fill();

            // Reset shadow settings
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        // Function to interpolate between two hex colors
        function interpolateColor(color1, color2, factor) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            const r = Math.round(c1.r + (c2.r - c1.r) * factor);
            const g = Math.round(c1.g + (c2.g - c1.g) * factor);
            const b = Math.round(c1.b + (c2.b - c1.b) * factor);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Helper function to convert hex color to RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.replace('#', ''), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return { r, g, b };
        }

        // Handle Player Movement
        function handlePlayerMovement() {
            player.y += player.dy;
            player.dy += player.gravity;
            if (player.y > groundHeight - player.height) {
                player.y = groundHeight - player.height;
                player.dy = 0;
                player.jumpsLeft = 2; // Reset jumps on landing
            }
        }

        // Handle Obstacles
        function handleObstacles() {
            if (!glitchActive && Math.random() < 0.02) {
                const height = Math.random() * 30 + 20;
                obstacles.push({ x: canvas.width, y: groundHeight - height, width: 20, height });
            }

            obstacles = obstacles.filter((obstacle) => {
                ctx.fillStyle = obstacleColor;
                ctx.shadowBlur = obstacleGlow;
                ctx.shadowColor = obstacleColor;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                // Reset shadow settings
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                obstacle.x -= speed;

                // Collision detection
                if (
                    player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y
                ) {
                    isGameOver = true;
                }

                return obstacle.x + obstacle.width > 0;
            });
        }

        // Handle Coins
        function handleCoins() {
            if (Math.random() < 0.02) {
                coins.push({
                    x: canvas.width,
                    y: Math.random() * (groundHeight - 100) + 50,
                    symbol: coinSymbols[Math.floor(Math.random() * coinSymbols.length)],
                    size: 15,
                });
            }

            coins = coins.filter((coin) => {
                ctx.fillStyle = coinColor;
                ctx.shadowBlur = coinGlow;
                ctx.shadowColor = coinColor;
                ctx.beginPath();
                ctx.arc(coin.x + 7.5, coin.y + 7.5, 7.5, 0, Math.PI * 2);
                ctx.fill();

                // Draw smaller coin symbol
                ctx.fillStyle = 'black';
                ctx.font = 'bold 10px Arial';
                const textWidth = ctx.measureText(coin.symbol).width;
                ctx.fillText(coin.symbol, coin.x + 7.5 - textWidth / 2, coin.y + 10);

                // Reset shadow settings
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                coin.x -= speed;

                // Collect coin
                if (
                    player.x < coin.x + coin.size &&
                    player.x + player.width > coin.x &&
                    player.y < coin.y + coin.size &&
                    player.y + player.height > coin.y
                ) {
                    playCoinSound();
                    score++;

                    // Update top score
                    if (score > topScore) {
                        topScore = score;
                        localStorage.setItem('topScore', topScore);
                        document.getElementById('topScore').innerText = `Top Score: ${topScore}`;
                    }

                    // Level up and increase speed
                    if (score % 8 === 0) {
                        level++;
                        speed += 0.5;

                        // Randomly change colors of elements
                        obstacleColor = getRandomColor();
                        coinColor = getRandomColor();
                        starColor = getRandomColor();

                        // Randomly set glow effects
                        obstacleGlow = Math.random() * 20;
                        coinGlow = Math.random() * 20;
                        starGlow = Math.random() * 5;
                        playerGlow = Math.random() * 20;
                    }

                    // Add fragments for animation
                    for (let i = 0; i < 5; i++) {
                        fragments.push({
                            x: coin.x,
                            y: coin.y,
                            dx: Math.random() * 4 - 2,
                            dy: Math.random() * -4,
                            size: 3,
                            life: 30,
                            color: coinColor, // Use current coin color
                        });
                    }
                    return false;
                }

                return true;
            });
        }

        // Draw Fragments
        function drawFragments() {
            fragments = fragments.filter((fragment) => {
                ctx.fillStyle = fragment.color || 'gold';
                ctx.fillRect(fragment.x, fragment.y, fragment.size, fragment.size);
                fragment.x += fragment.dx;
                fragment.y += fragment.dy;
                fragment.dy += 0.1; // Gravity
                return --fragment.life > 0;
            });
        }

        // Draw Score and Level
        function drawScoreAndLevel() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 10, 30); // Top-left corner
            ctx.fillText(`Level: ${level}`, canvas.width - 100, 30); // Top-right corner
        }

        // Spawn Glitch Coin
        function spawnGlitchCoin() {
            if (!glitchActive && Math.random() < 0.002 && !glitchCoin) { // Reduced spawn rate
                glitchCoin = { x: canvas.width, y: Math.random() * (groundHeight - 100) + 50, size: 30, pulse: 0 };
            }
        }

        // Handle Glitch Coin
        function handleGlitchCoin() {
            if (!glitchCoin) return;

            if (glitchCoin.collected) {
                // Animate glitch coin into multiple colours
                glitchCoin.animationFrame++;

                // Animate for 30 frames
                if (glitchCoin.animationFrame > 30) {
                    glitchCoin = null;
                    return;
                }

                // Draw the glitch coin with changing colors
                glitchCoin.pulse = Math.sin(frameCount / 10) * 5 + 30;
                ctx.fillStyle = `hsl(${glitchCoin.animationFrame * 12}, 100%, 50%)`;
                ctx.beginPath();
                ctx.arc(glitchCoin.x + 15, glitchCoin.y + 15, glitchCoin.pulse / 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw large BTC symbol
                ctx.fillStyle = 'black';
                ctx.font = 'bold 18px Arial';
                const textWidth = ctx.measureText('₿').width;
                ctx.fillText('₿', glitchCoin.x + 15 - textWidth / 2, glitchCoin.y + 22);

            } else {
                // Pulse animation for glitch coin
                glitchCoin.pulse = Math.sin(frameCount / 10) * 5 + 30;

                ctx.fillStyle = 'lime';
                ctx.beginPath();
                ctx.arc(glitchCoin.x + 15, glitchCoin.y + 15, glitchCoin.pulse / 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw large BTC symbol
                ctx.fillStyle = 'black';
                ctx.font = 'bold 18px Arial';
                const textWidth = ctx.measureText('₿').width;
                ctx.fillText('₿', glitchCoin.x + 15 - textWidth / 2, glitchCoin.y + 22);

                glitchCoin.x -= speed;

                if (
                    player.x < glitchCoin.x + glitchCoin.size &&
                    player.x + player.width > glitchCoin.x &&
                    player.y < glitchCoin.y + glitchCoin.size &&
                    player.y + player.height > glitchCoin.y
                ) {
                    playGlitchCoinSound(); // Play glitch coin sound
                    glitchActive = true;
                    glitchTimer = 300; // 5 seconds at 60 FPS
                    obstacles = [];

                    glitchCoin.collected = true;
                    glitchCoin.animationFrame = 0;

                    // Add multi-coloured fragments for animation
                    for (let i = 0; i < 20; i++) {
                        fragments.push({
                            x: glitchCoin.x + glitchCoin.size / 2,
                            y: glitchCoin.y + glitchCoin.size / 2,
                            dx: Math.random() * 6 - 3,
                            dy: Math.random() * -6,
                            size: 4,
                            life: 40,
                            color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                        });
                    }
                }

                if (glitchCoin && glitchCoin.x < -30) glitchCoin = null;
            }
        }

        // Glitch Effect
        function drawGlitchEffect() {
            if (glitchActive) {
                ctx.strokeStyle = `rgba(0, 255, 0, ${Math.sin(frameCount / 5) * 0.5 + 0.5})`;
                ctx.lineWidth = 5;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Game Loop
        function gameLoop() {
            if (isGameOver) {
                // Show game over screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '16px Arial';
                ctx.fillText('Press SPACE or tap to restart', canvas.width / 2, canvas.height / 2 + 20);
                ctx.textAlign = 'left';
                return;
            }

            if (!gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('₿itcoin Runner', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '16px Arial';
                ctx.fillText('Press SPACE or tap to start', canvas.width / 2, canvas.height / 2 + 20);
                ctx.textAlign = 'left';
                return;
            }

            frameCount++;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();
            generateGroundObjects();
            drawGround();
            drawPlayer();
            handlePlayerMovement();
            handleObstacles();
            handleCoins();
            drawFragments();
            spawnGlitchCoin();
            handleGlitchCoin();
            drawGlitchEffect();
            drawScoreAndLevel();

            if (glitchActive) {
                glitchTimer--;
                if (glitchTimer <= 0) glitchActive = false;
            }

            // Update player color progress
            player.colorProgress += 0.01 * player.colorDirection;
            if (player.colorProgress >= 1) {
                player.colorProgress = 1;
                player.colorDirection = -1;
            } else if (player.colorProgress <= 0) {
                player.colorProgress = 0;
                player.colorDirection = 1;
            }

            requestAnimationFrame(gameLoop);
        }

        // Restart Game
        function restartGame() {
            score = 0;
            level = 1;
            obstacles = [];
            coins = [];
            fragments = [];
            glitchCoin = null;
            glitchActive = false;
            speed = Math.max(3, canvasWidth / 300);
            isGameOver = false;
            frameCount = 0;
            gameStarted = true;
            groundObjects = [];
            player.colorProgress = 0;
            player.colorDirection = 1;
            player.y = groundHeight - player.height;
            player.dy = 0;
            player.jumpsLeft = 2;

            // Initialize element colors and glow effects at the start
            obstacleColor = getRandomColor();
            coinColor = getRandomColor();
            starColor = getRandomColor();
            obstacleGlow = Math.random() * 20;
            coinGlow = Math.random() * 20;
            starGlow = Math.random() * 5;
            playerGlow = Math.random() * 20;

            gameLoop();
        }

        // Start Game on Tap or Space
        function handleInteraction() {
            if (!gameStarted || isGameOver) {
                restartGame();
            } else if (player.jumpsLeft > 0) {
                player.dy = player.jump;
                player.jumpsLeft--;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleInteraction();
            }
        });

        // Improved touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleInteraction();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('click', (e) => {
            e.preventDefault();
            handleInteraction();
        });

        // Also listen for taps on the canvas parent for better mobile experience
        document.body.addEventListener('touchstart', (e) => {
            if (e.target === canvas || canvas.contains(e.target)) {
                e.preventDefault();
                handleInteraction();
            }
        }, { passive: false });

        document.getElementById('topScore').innerText = `Top Score: ${topScore}`;

        // Initialize the game
        obstacleColor = getRandomColor();
        coinColor = getRandomColor();
        starColor = getRandomColor();
        obstacleGlow = Math.random() * 20;
        coinGlow = Math.random() * 20;
        starGlow = Math.random() * 5;
        playerGlow = Math.random() * 20;

        gameLoop();
    </script>
</body>
</html>
